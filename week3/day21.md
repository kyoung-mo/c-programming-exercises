# [3주차: 임베디드 필수 자료구조 (Data Structures)]
## Day 21. 유한상태 머신 (FSM) - 함수 포인터 활용
- **입력:** 이벤트(버튼 클릭, 타임아웃 등)
- **출력:** 상태 전이 로그 및 액션 실행
- **제약조건:** `switch-case` 대신 상태별 구조체와 함수 포인터 테이블 사용.
- **실행결과:** `IDLE ->(Button) -> RUN`

```c
=== Day 21: Visual FSM Implementation ===
Initial State: [IDLE]

--------------------------------------------------
[TRANSITION] IDLE --(EVT_BUTTON_PRESS)--> RUN
--------------------------------------------------
   (Running... Motor spinning ⚙️)
--------------------------------------------------
[TRANSITION] RUN --(EVT_TIMEOUT)--> IDLE
--------------------------------------------------
--------------------------------------------------
[TRANSITION] IDLE --(EVT_BUTTON_PRESS)--> RUN
--------------------------------------------------
--------------------------------------------------
[TRANSITION] RUN --(EVT_RESET)--> ERROR
--------------------------------------------------
   (Waiting... ⚠️ System Halted)
--------------------------------------------------
[TRANSITION] ERROR --(EVT_RESET)--> IDLE
--------------------------------------------------

>> Simulation Ended.
```

<img width="1200" height="800" alt="image" src="https://github.com/user-attachments/assets/f40049f2-1a56-4f72-be97-c6ef68ac46aa" />


- 참고
    
    임베디드 시스템 펌웨어의 꽃인 **유한 상태 머신(FSM, Finite State Machine)**을 구현하는 것입니다.
    `switch (state) { case ... }` 로 도배된 "스파게티 코드"를 탈피하고, **함수 포인터 테이블**을 사용해 **구조적이고 확장이 쉬운 FSM**을 만드는 것이 핵심입니다.
    
    ---
    
    ### 1. 핵심 원리: 테이블 기반 FSM (Table-Driven FSM)
    
    상태(State)를 배열의 **인덱스**로, 행동(Action)을 **함수 포인터**로 매핑합니다.
    메인 루프는 현재 상태가 누구인지 알 필요 없이, 그저 **"현재 상태의 함수를 실행해라"**라고 명령만 내리면 됩니다.
    
    **그림의 핵심 논리:**
    
    1. **IDLE ↔ RUN:** 버튼(`BUTTON_PRESS`)으로 켜고, 타임아웃(`TIMEOUT`)으로 꺼집니다.
    2. **RUN → ERROR:** 실행 중 리셋(`RESET`) 신호가 오면 에러로 빠집니다.
    3. **ERROR → IDLE:** 에러 상태에서 리셋(`RESET`) 신호가 오면 초기화(IDLE)됩니다.

---


### 코드

```c

```

### 실행 결과

```bash

```
